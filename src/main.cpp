BeatrizAcosta
beatrizacosta
Invisible

BeatrizAcosta ‚Äî 03/04/2024 2:06 PM
Great job fixing the auton!!
Omm ‚Äî 03/04/2024 3:07 PM
Thanks
It was phoebe and I who fixed it
Also used you for loop lol
So it was all of us
Omm ‚Äî 03/04/2024 3:37 PM
How was your hackathon?
BeatrizAcosta ‚Äî 03/04/2024 8:23 PM
Great! I was able to learn how to use Unity to create games and I loved it.
Omm ‚Äî 03/04/2024 8:33 PM
Let's goooo
I was messing with unity in my python class lol 
BeatrizAcosta ‚Äî 03/05/2024 3:39 PM
You should apply
Image
Omm ‚Äî 03/06/2024 5:02 PM
Damm
Send me the link
Omm ‚Äî 03/11/2024 6:24 PM
Hey
You did a great job today
BeatrizAcosta ‚Äî 03/11/2024 6:50 PM
Thank you! You guys were also great.
Omm ‚Äî 03/11/2024 7:31 PM
Well idk but was something bugging you? Like arre you good? 
BeatrizAcosta ‚Äî 03/12/2024 9:53 AM
No I was fine yesterday just a little nervous before the Girl Scouts came because I didn‚Äôt know what to expect.
BeatrizAcosta ‚Äî 03/12/2024 10:45 AM
Also here is the link to the Snapchat internship I forgot to send  https://www.snapacademies.com/sea
SEA
Omm ‚Äî 03/12/2024 11:23 AM
Oh thanks
Omm ‚Äî 03/12/2024 11:23 AM
Well it went well... let's gooo
Omm ‚Äî 03/15/2024 11:06 PM
each focused on design, marketing, and writing.

click and save one for later.

we recommend starting with dmw_000.

‚Äãdmw_000 -- how to leverage the internet‚Äã

‚Äãdmw_001 -- marketing 101.‚Äã

‚Äãdmw_002 -- design 101.‚Äã

‚Äãdmw_003 -- how to write better copy.‚Äã

‚Äãdmw_004 -- video 101.‚Äã

‚Äãdmw_005 -- short-form videos 101.‚Äã

‚Äãdmw_006 -- building your own personal brand.‚Äã

more will be dropping on a weekly basis.

let us know what other topics you would like us to cover!
oh i
wait
dmw_000 - https://www.youtube.com/watch?v=jPTIeD7DtKQ&list=PLOHhQHMQ2uzsNNznHWLQX-n7oAtF-EdjS&index=2
YouTube
buildspace
dmw class 0: why design, marketing, and writing matter.
Image
https://youtube.com/playlist?list=PLOHhQHMQ2uzsNNznHWLQX-n7oAtF-EdjS&si=jPQJmvtaU931tR6J
YouTube
dmw lectures
introduction to design, marketing, and writing. wtf are these things and why you should care.
Image
Image
Image
Image
lol
Omm ‚Äî 03/18/2024 3:29 PM
pros::c::quaternion_s_t qt = imu_sensor.get_quaternion();
        std::string text = "IMU quaternion: {x: " + std::to_string(qt.x) + ", y: " + std::to_string(qt.y) + ", z: " + std::to_string(qt.z) + ", w: " + std::to_string(qt.w) + "}\n";
        pros::lcd::set_text(1, text);
 
pros::c::quaternion_s_t qt =imu_sensor.get_quaternion();
std::string text = "IMU quaternion: {x: " + std::to_string(qt.x) + ", y: " + std::to_string(qt.y) + ", z: " + std::to_string(qt.z) + ", w: " + std::to_string(qt.w) + "}\n";
pros::lcd::set_text(1, text);
BeatrizAcosta ‚Äî 03/25/2024 12:46 PM
https://sites.google.com/view/mcengineeringclub/home?authuser=0
MC Engineering Club
BeatrizAcosta ‚Äî 03/25/2024 1:17 PM
Image
Omm ‚Äî 03/27/2024 12:09 AM
Hey, 
Have a look at this!
https://omm.needs.rest/MCEC_-_Moorpark_College_Engineering_Club_-_Opera_2024-03-27_00-05-09.mp4
Ignore the music... I thought it won't capture that
BeatrizAcosta ‚Äî 03/27/2024 12:29 AM
That looks amazing!!!!
Omm ‚Äî 03/27/2024 12:50 AM
Thanks
Omm ‚Äî 03/27/2024 2:02 PM
Hey,
I was learning the game rules and found this
Image
It said this would be the field
BeatrizAcosta ‚Äî 03/27/2024 4:26 PM
That field is for the high school VEX comps
This is the pic of how Vex U autonomous is set up
Image
Omm ‚Äî 03/27/2024 4:39 PM
Oh ok
BeatrizAcosta ‚Äî 03/28/2024 3:49 PM
#include "main.h"
#include "pros/misc.h"
#include "pros/motors.hpp"
#include <math.h>
#include <string>
#include <type_traits>
Expand
message.txt
10 KB
Omm ‚Äî 03/28/2024 4:46 PM
void autonomous()
{
	pros::Rotation RotationSensor(12);
	pros::Imu imu_sensor(19);

	std::shared_ptr<ChassisController> bot = ChassisControllerBuilder()
Expand
thing_I_wrote.txt
3 KB
Omm ‚Äî Today at 4:42 PM
#include "main.h"
#include "pros/misc.h"
#include "pros/motors.hpp"
#include <math.h>
#include <string>
#include <vector>
Expand
auton_new.txt
12 KB
BeatrizAcosta ‚Äî Today at 6:02 PM
https://github.com/purduesigbots/pros
GitHub
GitHub - purduesigbots/pros: Source code for PROS kernel: open sour...
Source code for PROS kernel: open source C/C++ development for the VEX V5 microcontroller - purduesigbots/pros
GitHub - purduesigbots/pros: Source code for PROS kernel: open sour...
Omm ‚Äî Today at 6:13 PM
#include "main.h"
#include "pros/misc.h"
#include "pros/motors.hpp"
#include <math.h>
#include <string>
#include <vector>
Expand
message.txt
13 KB
Ôªø
Omm
maiommhoon
|Ôø£Ôø£Ôø£Ôø£Ôø£Ôø£Ôø£Ôø£Ôø£Ôø£Ôø£Ôø£Ôø£Ôø£|
|      I do tap tap on laptop.  üë®‚Äçüíª       |
|   me -    "ommshah.vercel.app"     |
|ÔºøÔºøÔºøÔºøÔºøÔºøÔºøÔºøÔºøÔºøÔºøÔºøÔºøÔºø|
                     \ (‚Ä¢‚ó°‚Ä¢) /
                       \       /
#include "main.h"
#include "pros/misc.h"
#include "pros/motors.hpp"
#include <math.h>
#include <string>
#include <vector>
#include "okapi/api.hpp"
#include "okapi/api/chassis/controller/chassisControllerPid.hpp"
using namespace okapi;
pros::Motor Catapult(1, false);
pros::Motor Arm(17, false);
pros::Motor Intake(13, false);
pros::Rotation RotationSensor(12);
pros::ADIDigitalOut Piston('A');
pros::Imu imu_sensor(19);

/**
 * A callback function for LLEMU's center button.
 *
 * When this callback is fired, it will toggle line 2 of the LCD text between
 * "I was pressed!" and nothing.


/**
 * Runs initialization code. This occurs as soon as the program is started.
 *
 * All other competition modes are blocked by initialize; it is recommended
 * to keep execution time for this mode under a few seconds.

/**
 * A callback function for LLEMU's center button.
 *
 * When this callback is fired, it will toggle line 2 of the LCD text between
 * "I was pressed!" and nothing.
 */

void on_center_button()
{
	static bool pressed = false;
	pressed = !pressed;
	if (pressed)
	{
		pros::lcd::set_text(2, "I was pressed!");
	}
	else
	{
		pros::lcd::clear_line(2);
	}
}

/**
 * Runs initialization code. This occurs as soon as the program is started.
 *
 * All other competition modes are blocked by initialize; it is recommended
 * to keep execution time for this mode under a few seconds.
 */
void initialize()
{
	pros::lcd::initialize();
	pros::lcd::set_text(1, "Hello PROS User!");

	pros::lcd::register_btn1_cb(on_center_button);
}

/**
 * Runs while the robot is in the disabled state of Field Management System or
 * the VEX Competition Switch, following either autonomous or opcontrol. When
 * the robot is enabled, this task will exit.
 */
void disabled() {}

/**
 * Runs after initialize(), and before autonomous when connected to the Field
 * Management System or the VEX Competition Switch. This is intended for
 * competition-specific initialization routines, such as an autonomous selector
 * on the LCD.
 *
 * This task will exit when the robot is enabled and autonomous or opcontrol
 * starts.
 */
void competition_initialize() {}

/**
 * Runs the user autonomous code. This function will be started in its own task
 * with the default priority and stack size whenever the robot is enabled via
 * the Field Management System or the VEX Competition Switch in the autonomous
 * mode. Alternatively, this function may be called in initialize or opcontrol
 * for non-competition testing purposes.
 *
 * If the robot is disabled or communications is lost, the autonomous task
 * will be stopped. Re-enabling the robot will restart the task, not re-start it
 * from where it left off.
 *
 *
 *
 */


// This is PID 
// !Don't Touch it
	std::shared_ptr<ChassisController> bot = ChassisControllerBuilder()
	 .withMotors(18, -20, -9, 14) // front right and back right were reversed in order to go forward
	 // change P then D first then I only if necessary
	 // start with P I and D with zero
	 .withGains( // 0.7, 0, 0.1 results: faster, shaking less violently 0
		 // 0.5 =
		 {0.001, 0, 0},	  // Distance controller gains
		 {0.001, 0, 0},	  // turn controller gains
		 {0.0, 0, 0.0000} // Angle controller (helps bot drive straight)
		 )
	 .withMaxVelocity(200)
	 // Green gearset, 3 inch wheel diam, 9 inch wheel track
	 .withDimensions(AbstractMotor::gearset::green, {{5_in, 15_in}, imev5GreenTPR})
	 .build();

// This set the Catapult's Position
void setCatapult(){
	// Set the Rotation Sensor
	pros::Rotation RotationSensor(12);

	// * Run until the Catault is at the desired position which is Down
	while (true)
	{
		// * The Rotation Sensor has value with no points so if it's 360.00, it's 36000
		// If the Rotation Sensor is less than 33998
		if(RotationSensor.get_angle() < 33998)
		{
			// Move the Catapult down
			Catapult.move_velocity(200);
		}
		else
		{
			// Stop the Catapult
			Catapult.move_velocity(0);
			// Break the loop
			break;
		}
	}
}

// * This function is to get the ball into the Catapult
void getBall(){
	setCatapult(); // Set the catapult
	Intake.move_velocity(-200); // The intake starts
	Arm.move_absolute(700, 200); // The Arm for intake goes down
	pros::delay(500); // Wait for the arm to go down
	for (int i = 0; i >= -1500; i = i - 500) // Slowly (exponentially) move the arm up
	{
		Intake.move_velocity(-100);
		Arm.move_absolute(i, 200);
		pros::delay(250);
	}
}

// * This function is to turn the bot to the left
void negativeTurn(int degrees)
{
	// !Reset's the IMU's rotation 
    imu_sensor.tare_rotation();

	bot->turnAngle(-degrees*1_deg); // Turn the bot to the left

	// * Solve the greater Error - so If the error is -40 degrees, ask the bot to turn -40 degrees
	if(imu_sensor.get_rotation() <= -degrees)
	{
		int value = degrees - abs(imu_sensor.get_rotation()); // Gets The error
		bot->turnAngle(-round(value)*1_deg); // Turns it
	}

	// * Solve minor error, So we turned the bot -40 degrees in above examples 
	// * but bot is not accurate so it just turned -30 degrees 
	// * so until it's not greater than or equal to desired degrees, change -10 more degrees
	while(imu_sensor.get_rotation() <= -degrees)
	{
    	bot->turnAngle(-10_deg); // Turn the bot 10 degrees to Left
		if(imu_sensor.get_rotation() >= -(degrees)) // break the loop when it's greatar than it
		{
			break;
		}
	}
}

// This function is to turn the bot to the right
void positiveTurn(int degrees)
{
	// !Reset's the IMU's rotation 
	imu_sensor.tare_rotation();
	setCatapult(); // Set the catapult
	bot->turnAngle(degrees*1_deg); // Turn the bot to the right

	// * Solve the greater Error - so If the error is 40 degrees, ask the bot to turn 40 degrees
	if(round(imu_sensor.get_rotation()) <= degrees)
	{
		int value = abs(imu_sensor.get_rotation()) - degrees; // Gets The error
		bot->turnAngle(-round(value)*1_deg); // Turns it
	}

	// * Solve minor error, So we turned the bot 40 degrees in above examples 
	// * but bot is not accurate so it just turned 30 degrees 
	// * so until it's not greater than or equal to desired degrees, change 10 more degrees
	while(round(imu_sensor.get_rotation()) <= degrees)
	{
    	bot->turnAngle(10_deg); // Turn the bot 10 degrees to Right
		if(imu_sensor.get_rotation() >= degrees) // break the loop when it's greatar than it
		{
			break;
		}
	}
}

void redAuton() {

	// * Part 1 - Set the Catapult, move forward, turn to the left
	setCatapult();
	bot->moveDistance(24_in);
	negativeTurn(70);

	// * Part 2 - Move forward, Get the ball and turn to the left for launching
	bot->moveDistance(18_in);
	getBall();
	negativeTurn(125);

	// * Part 3 - Launch the ball, have a delay and turn to the right to get another ball
	Catapult.move_velocity(300); // The catapult goes down
	pros::delay(1000); // Wait for launch
	positiveTurn(80);

	// * Part 4 - Move forward, get the ball and turn to the left for launching
	bot->moveDistance(9_in);
	getBall();
	negativeTurn(100);

	// * Part 5 - Launch the ball, have a delay and turn to the right to get another ball
	Catapult.move_velocity(300); // The catapult goes down
	pros::delay(500); // Wait for launch
	Catapult.move_velocity(0); // The catapult stops

	// * Part 6 - Move forward, have a delay and move foward for THE SLAPP TO THE BALL
	positiveTurn(70);
	pros::delay(100);
	bot->moveDistance(3.8_ft);

	pros::delay(1000); // Wait for launch
	pros::lcd::set_text(5, std::to_string('The Program ends'));
}

void autonomous()
{
	pros::Rotation RotationSensor(12);

	pros::lcd::set_text(1, "THIS IS AUTON!");

	// ! Call the redAuton function when needed
	redAuton();

	// TODO: Code the blueAuton function
	// blueAuton();
}

/**
 * Runs the operator control code. This function will be started in its own task
 * with the default priority and stack size whenever the robot is enabled via
 * the Field Management System or the VEX Competition Switch in the operator
 * control mode.
 *
 * If no competition control is connected, this function will run immediately
 * following initialize().
 *
 * If the robot is disabled or communications is lost, the
 * operator control task will be stopped. Re-enabling the robot will restart the
 * task, not resume it from where it left off.
 */
void opcontrol()
{

	pros::Motor FrontLeft(18, false);
	pros::Motor FrontRight(20, true);
	pros::Motor BackLeft(14, true);
	pros::Motor BackRight(9, false);
	pros::Motor MidRight(15, false);
	pros::Motor MidLeft(16, false);
	pros::Motor Catapult(1, false);
	pros::Motor Arm(17, false);
	pros::Motor Intake(13, false);
	pros::Rotation RotationSensor(12);
	pros::ADIDigitalOut Piston('A');
	pros::Imu imu_sensor(19);
	// imu_sensor.reset();



	pros::lcd::set_text(1, "READY TO DRIVE");
	int yMotion;
	int xMotion;
	int value;

	pros::Controller master(pros::E_CONTROLLER_MASTER);
	Catapult.tare_position();
	Arm.tare_position();

	//-33 Arm encoder units for intake


	imu_sensor.tare_yaw();
	imu_sensor.tare_roll();
	imu_sensor.tare_pitch();

	while (true)
	{

	pros::lcd::set_text(1, "YAW: " + std::to_string(imu_sensor.get_yaw()));
	pros::lcd::set_text(2, "PITCH: " + std::to_string(imu_sensor.get_roll()));
	pros::lcd::set_text(3, "ROLL: " + std::to_string(imu_sensor.get_pitch()));

	// pros::lcd::set_text(2, "IMU quaternion y: " + std::to_string(qt.y));
	// pros::lcd::set_text(3, "IMU quaternion z: " + std::to_string(qt.z));
	// pros::lcd::set_text(4, "IMU quaternion w: " + std::to_string(qt.w));

		// pros::lcd::set_text(1, "Arm:" + std::to_string(Arm.get_position()));
		// pros::lcd::set_text(2, "Front Right Motor:" + std::to_string(FrontRight.get_position()));
		// pros::lcd::set_text(3, "Back Left Motor:" + std::to_string(BackLeft.get_position()));
		// pros::lcd::set_text(4, "Back Right Motor:" + std::to_string(BackRight.get_position()));
		// pros::lcd::set_text(5, "Rotation Sensor: " + std::to_string(RotationSensor.get_position()));
		// pros::lcd::set_text(6, "Catapult: " + std::to_string(Catapult.get_position()));


		// driving control code

		yMotion = master.get_analog(pros::E_CONTROLLER_ANALOG_RIGHT_X); // ik this looks wrong, but it works
		xMotion = master.get_analog(pros::E_CONTROLLER_ANALOG_LEFT_Y);

		int right = -xMotion + yMotion; //-power + turn
		int left = xMotion + yMotion;	// power + turn

		FrontLeft.move(left); // Swap negatives if you want the bot to drive in the other direction
		BackLeft.move(-left);
		// MidLeft.move(left);
		BackRight.move(right);
		FrontRight.move(-right);
		// MidRight.move(right);

		if (master.get_digital(DIGITAL_R1))
		{
			RotationSensor.set_data_rate(0);
			Catapult.move_velocity(200);
			pros::lcd::set_text(5, std::to_string(RotationSensor.get_angle()));
		}
		else if (RotationSensor.get_angle() <= 33998)
		{ // 3050 ->2700(no data rate)-> 3565 (data rate)
			Catapult.move_velocity(200);
		}
		// value to launch (34000) is value due to catapult starting position not being zero
		else
		{
			// RotationSensor.set_data_rate(55);
			Catapult.move_velocity(0);
		}

		if (master.get_digital(DIGITAL_L1))
		{
			Arm.move_velocity(-112);
			pros::lcd::set_text(5, "Arm Velocity:" + std::to_string(Arm.get_actual_velocity()));
		}
		else if (master.get_digital(DIGITAL_L2))
		{
			Arm.move_velocity(112);
			pros::lcd::set_text(5, "Arm Velocity:" + std::to_string(Arm.get_actual_velocity()));
		}
		else
		{
			Arm.move_velocity(0);
		}

		if (master.get_digital(DIGITAL_R2))
		{
			Intake.move_velocity(-200);
			pros::lcd::set_text(5, "Intake Velocity:" + std::to_string(Intake.get_actual_velocity()));
		}
		else if (master.get_digital(DIGITAL_DOWN))
		{
			Intake.move_velocity(200);
			pros::lcd::set_text(5, "Intake Velocity:" + std::to_string(Intake.get_actual_velocity()));
		}

		/* 		if(master.get_digital(DIGITAL_DOWN))
				{
					Intake.move_velocity(200);
					pros::lcd::set_text(5,"Intake Velocity:" + std::to_string(Intake.get_actual_velocity()));
				}
				else {
					Intake.move_velocity(0);
				} */

		if (master.get_digital(DIGITAL_A))
		{
			Piston.set_value(false);
		}
		else
		{
			Piston.set_value(true);
		}

		pros::delay(20);
	}
}